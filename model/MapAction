include('../auto')

class MapAction {
	static _item_cell_actions // [item:[cell:[actions]]]
	static _cell_item_actions // [cell:[item:[actions]]]
	static _cell_item_bestAction // [cell:[item:action]]
	
	// switch entre toutes les AREA_X du jeu pour créer chaque action possible.
	static switch_itemarea_addActions = [
		AREA_POINT: function(item){
			// pour chaque cible valide de l'item
			for(var entity in item.targetSet()){
				if(entity==Fight.self){
					// si c'est moi la cible, je ne peux que le lancer sur moi même, si la minrange le permet
					if(item.minRange == 0) MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				} else {
					// sinon je liste toutes les cases depuis lesquelles je peux tirer sur la cible
					var cells = getCellsToUseItemOnCell(item, entity.cell, [])
					for(var cellId in cells) MapAction.addAction(item, Map.getCell(cellId), entity.cell)
				}
			}
		},
	]
	
	static refresh() {
		// remise à zéro des maps
		_item_cell_actions = []
		_cell_item_actions = []
		_cell_item_bestAction = []
		// pour chaque item
		for(var item in Fight.self.items){
			// si j'ai le cooldown
			if(getCooldown(item, Fight.self) > 0) continue
			// selon l'area de l'item
			if(switch_itemarea_addActions[item.area]!=null){
				switch_itemarea_addActions[item.area](item)
			}else{
				debugW('AREA unhandled in MapAction.refresh(): ' + item.area)
			}
		}
	}
	
	static addAction(item, fromCell, targetCell){
		var action = Action(item, fromCell, targetCell)
		
		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = []
		if(!_item_cell_actions[item][fromCell]) _item_cell_actions[item][fromCell] = []
		push(_item_cell_actions[item][fromCell], action)
		
		// ajout dans la map par cell puis items
		if(!_cell_item_actions[fromCell]) _cell_item_actions[fromCell] = []
		if(!_cell_item_actions[fromCell][item]) _cell_item_actions[fromCell][item] = []
		push(_cell_item_actions[fromCell][item], action)
		
		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres:
		// => réduction forte de la complexité
		// => pas de perte normalement si j'ai déjà check avant les effets qui change drastiquement le scoring, genre kill un leek
		// limitation > changement drastique de score après certain effet, genre libération.
		// possible solution > implem un préscoring envisageant l'action précédente de debuff, doit pas y en avoir 40
		if(!_cell_item_bestAction[fromCell]) _cell_item_bestAction[fromCell] = []
		if(!_cell_item_bestAction[fromCell][item]) _cell_item_bestAction[fromCell][item] = action
		else if(_cell_item_bestAction[fromCell][item].score < action.score) _cell_item_bestAction[fromCell][item] = action
	}
	
	static getPotentialCombo(entity){
		var bestCombo = null
		// all reachableCells
		//var arrayCombo = []
		for(var cell:var mp in entity.reachableCells){
			if(!_cell_item_bestAction[cell]) _cell_item_bestAction[cell] = [];
			//when i handle move after combo
			var combo = Combo()
			var tpleft = entity.tp
			var inHand = entity.getWeaponInHand()
						
			// ajout des actions sur moi mm dans les meilleurs moves sur cette case
			if(_cell_item_bestAction[Fight.selfCell]){
				for(var item: var action in _cell_item_bestAction[Fight.selfCell]){
					if(_cell_item_bestAction[cell][item]){
						if(action.score > _cell_item_bestAction[cell][item].score) _cell_item_bestAction[cell][item] = action
					}else{
						_cell_item_bestAction[cell][item] = action
					}
				}
			}
			// note : cette façon de faire en dessous "casse" les clés, le string() renvoie tjr le bon item, mais les champs sont null
			//_cell_item_bestAction[cell] += _cell_item_bestAction[Fight.selfCell]
			
			// tri par score des actions
			_cell_item_bestAction[cell] = arraySort(_cell_item_bestAction[cell], function(a,b){	
				if(a.score<b.score) return 1;
				else if(a.score>b.score) return -1;
				return 0;
			});
			
			// ajout du meilleur score sur la case jusqu'à épuisement des TP/CD
			for(var item:var action in _cell_item_bestAction[cell]){
				var switchCost = item.isWeap && item != inHand ? 1 : 0
				while(item.cost+switchCost<=tpleft){
					tpleft-=item.cost+switchCost
					if(switchCost==1){ inHand = item; switchCost = 0 }
					combo.add(action)
					if(item.haveCD) break
				}
			}
			// recherche d'une case de fin de tour
			var currentCell = combo.getCurrentCell()
			var mpleft = Fight.self.mp - Fight.self.reachableCells[currentCell]
			combo.addFinalDanger(MapDanger.findBestDanger(currentCell, mpleft))
			/*
			var scor = round(combo.getScore())
			arrayCombo[scor] = combo
			mark(cell.id, COLOR_BLUE)
			markText(cell.id, scor)
			*/
			if(!bestCombo || bestCombo.getScore() < combo.getScore()){
				bestCombo = combo
			}
		}
		/*
		for(var scor: var combo in arrayCombo) {
			debug(scor + ": " + combo)
		}
		pause()
		clearMarks()
		*/

		return bestCombo
	}
}