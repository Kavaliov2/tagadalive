include('../../auto')

class MapAction {
	static _item_cell_actions // [item:[cell:[actions]]]
	static _cell_item_actions // [cell:[item:[actions]]]
	static _cell_item_bestAction // [cell:[item:action]]
	
	// switch entre toutes les AREA_X du jeu pour créer chaque action possible.
	static switch_itemarea_addActions = [
		AREA_POINT: function(item){
			// pour chaque cible valide de l'item
			for(var entity in item.targetSet()){
				if(entity==Fight.self){
					// si c'est moi la cible, je ne peux que le lancer sur moi même, si la minrange le permet
					if(item.minRange == 0) MapAction.addAction(item, Fight.selfCell, Fight.selfCell)
				} else {
					// sinon je liste toutes les cases depuis lesquelles je peux tirer sur la cible
					var cells = getCellsToUseItemOnCell(item, entity.cell, [])
					for(var cellId in cells) MapAction.addAction(item, Map.getCell(cellId), entity.cell)
				}
			}
		},
	]
	
	static refresh() {
		// remise à zéro des maps
		_item_cell_actions = []
		_cell_item_actions = []
		_cell_item_bestAction = []
		// pour chaque item
		for(var item in Fight.self.items){
			// si j'ai le cooldown
			if(getCooldown(item, Fight.self) > 0) continue
			// selon l'area de l'item
			if(switch_itemarea_addActions[item.area]!=null){
				switch_itemarea_addActions[item.area](item)
			}else{
				debugW('AREA unhandled in MapAction.refresh(): ' + item.area)
			}
		}
	}
	
	static getMapBestAction(){
		return _cell_item_bestAction
	}
	
	static addAction(item, fromCell, targetCell){
		var action = Action(item, fromCell, targetCell)
		
		// ajout dans la map par item puis cells
		if(!_item_cell_actions[item]) _item_cell_actions[item] = []
		if(!_item_cell_actions[item][fromCell]) _item_cell_actions[item][fromCell] = []
		push(_item_cell_actions[item][fromCell], action)
		
		// ajout dans la map par cell puis items
		if(!_cell_item_actions[fromCell]) _cell_item_actions[fromCell] = []
		if(!_cell_item_actions[fromCell][item]) _cell_item_actions[fromCell][item] = []
		push(_cell_item_actions[fromCell][item], action)
		
		// ici, je ne set sur chaque case, pour chaque item, que la meilleure action et pas les autres:
		// => réduction forte de la complexité
		// => pas de perte normalement si j'ai déjà check avant les effets qui change drastiquement le scoring, genre kill un leek
		// limitation > changement drastique de score après certain effet, genre libération.
		// possible solution > implem un préscoring envisageant l'action précédente de debuff, doit pas y en avoir 40
		if(!_cell_item_bestAction[fromCell]) _cell_item_bestAction[fromCell] = []
		if(!_cell_item_bestAction[fromCell][item]) _cell_item_bestAction[fromCell][item] = action
		else if(_cell_item_bestAction[fromCell][item].score < action.score) _cell_item_bestAction[fromCell][item] = action
	}
}