include('../../auto')

/*
 * L'objet Entity contient la synthèse des informations d'une entité allié ou adversaire.
 * Il y a un objet Entity instancié pour chacune des entités présente sur le champ de bataille.
 */
class Entity {
	id
	name
	cell
	totalLife
	life
	lifeMissing
	pwr
	str
	mgc
	wsd
	rst
	agi
	snc
	tp
	mp
	relShield
	absShield
	dmgReturn
	reachableCells
	items
	offensiveItems // will have a value on enemy leeks only
	offensiveItemsByTargets = [] // will have a value on ally leeks only
	turnOrder
	entityWhoPlayBefore
	cellsToIgnore = []
	isFriend
	isBulb
	effects = []
	effects_items = []
	psnTurn = 0
	psnTotal = 0
	psnlife
	altStr = 0
	altMgc = 0
	altAgi = 0
	altTP = 0
	altMP = 0
	// todo add more alt ?
	// todo add passive effect
	
	constructor(id){
		this.id = id
		this.name = getName(id)
		this.cell = Map.getCell(getCell(id))
		this.totalLife = getTotalLife(id)
		this.life = getLife(id)
		this.pwr = getPower(id)
		this.str = getStrength(id)
		this.mgc = getMagic(id)
		this.wsd = getWisdom(id)
		this.rst = getResistance(id)
		this.agi = getAgility(id)
		this.snc = getScience(id)
		this.tp = getTP(id)
		this.mp = getMP(id)
		this.relShield = getRelativeShield(id)
		this.absShield = getAbsoluteShield(id)
		this.dmgReturn = getDamageReturn(id)
		this.items = Items.getItems(id)
		this.turnOrder = getEntityTurnOrder(id)
		this.isFriend = isAlly(id)
		this.isBulb = isSummon(id)
		for(var e in getEffects(id)){
			var effect = EntityEffect(e)
			push(effects, effect)
			if(!this.effects_items[effect.item]) this.effects_items[effect.item] = []
			push(this.effects_items[effect.item], effect)
			// piste d'optimisation en ayant une meilleure structure pour les effets ici ?
			// les eval en dessous pourrait être déléguer à un tab pour éviter les ifelseif?
			// et ptete ajouter d'autres alt pour les autres stats ?
			if(effect.type == EFFECT_POISON){
				this.psnTurn+= effect.value
				this.psnTotal+= effect.value * effect.turns
			}else if(effect.type == EFFECT_HEAL){
				this.psnTurn+= -effect.value
				this.psnTotal+= -effect.value * effect.turns
			}else if(effect.type == EFFECT_SHACKLE_STRENGTH){
				this.altStr += -effect.value;
			//	}else if(effect.type == EFFECT_SHACKLE_MAGIC){
			//		this.altMgc -= value;
			}else if(effect.type == EFFECT_SHACKLE_TP){
				this.altTP += -effect.value;
			}else if(effect.type == EFFECT_SHACKLE_MP){
				this.altMP += -effect.value;
			}else if(effect.type == EFFECT_BUFF_STRENGTH || effect.type == EFFECT_RAW_BUFF_STRENGTH){
				this.altStr += effect.value;
			}else if(effect.type == EFFECT_BUFF_TP || effect.type == EFFECT_RAW_BUFF_TP){
				this.altTP += effect.value;
			}else if(effect.type == EFFECT_BUFF_MP || effect.type == EFFECT_RAW_BUFF_MP){
				this.altMP += effect.value;
			}else if(effect.type == EFFECT_BUFF_AGILITY || effect.type == EFFECT_RAW_BUFF_AGILITY){
				this.altAgi += effect.value;
			}
		}
		this.psnlife= this.life-this.psnTurn
	}

	/*
	 * Initialise certaines informations de l'objet Entity
	 * Certaines peuvent être dépendantes d'autres classes.
	 */
	init(){
		this.entityWhoPlayBefore = Fight.getListOfLeekWhoPlayBefore(this)
		for(var entity in this.entityWhoPlayBefore) {
			push(this.cellsToIgnore, entity.cell)
		}
		this.reachableCells = this.getReachableCells(
			[this.cell:0],
			this.mp,
			this.cellsToIgnore
		)
	}
	
	/*
	 * Retourne l'objet Item correspondant à l'arme dans les mains de l'entité
	 * @return une Item
	 */
	getWeaponInHand(){
		return Items.getItem(getWeapon(this))
	}

	/*
	 * Renvoie l'ensemble de cellules accessibles depuis la cellule (cells) avec la quantité de points de mouvements (mp) en utilisant les voisins.
	 * @param cells -> cellule à partir de laquelle je veux checker (format [Cell:distance]) donc par exemple ma [cellule courante:0]
	 * @param mp -> les points de mouvements
	 * @param ignoreCells -> cellules à ignorer par l'algorithme
	 * @return  un tableau contenant pour chaque cellules accessible [Cell:distance]
	 * 
	 */
	getReachableCells(cells, mp, ignoreCells){
		var stack = cells;
		var tmp = cells;
		var next = [];
		while(mp-->0){
			for(var currentWorkingCell: var dist in tmp){
				for(var c in currentWorkingCell.neighbors){
					if(stack[c] == null && (!Map.entityCells[c] || inArray(ignoreCells, c))){
						stack[c] = dist+1;
						next[c] = dist+1;
					}
				}
			}
			tmp = next;
			next = [];
		}
		return stack
	}
	
	getCurrentMaxHP(consequences){
		return consequences ? this.totalLife+consequences.getAlteration(this, Stats.HPMAX) : this.totalLife 
	}
	getCurrentHP(consequences){
		return consequences ? this.life+consequences.getAlteration(this, Stats.HP) : this.life 
	}
	getCurrentHPMissing(consequences){
		return this.getCurrentMaxHP(consequences) - this.getCurrentHP(consequences) 
	}
	getCurrentTP(consequences){
		return consequences ? this.tp+consequences.getAlteration(this, Stats.TP) : this.tp 
	}
	getCurrentMP(consequences){
		return consequences ? this.mp+consequences.getAlteration(this, Stats.MP) : this.mp 
	}
	getCurrentStr(consequences){
		return consequences ? this.str+consequences.getAlteration(this, Stats.STR) : this.str 
	}
	getCurrentMgc(consequences){
		return consequences ? this.mgc+consequences.getAlteration(this, Stats.MGC) : this.mgc 
	}
	getCurrentPwr(consequences){
		return consequences ? this.pwr+consequences.getAlteration(this, Stats.PWR) : this.pwr 
	}
	getCurrentWsd(consequences){
		return consequences ? this.wsd+consequences.getAlteration(this, Stats.WSD) : this.wsd 
	}
	getCurrentRst(consequences){
		return consequences ? this.rst+consequences.getAlteration(this, Stats.RST) : this.rst 
	}
	getCurrentAgi(consequences){
		return consequences ? this.agi+consequences.getAlteration(this, Stats.AGI) : this.agi 
	}
	getCurrentSnc(consequences){
		return consequences ? this.snc+consequences.getAlteration(this, Stats.SNC) : this.snc 
	}
	getCurrentAbs(consequences){
		return consequences ? this.absShield+consequences.getAlteration(this, Stats.ABSSHIELD) : this.absShield 
	}
	getCurrentRel(consequences){
		return consequences ? this.relShield+consequences.getAlteration(this, Stats.RELSHIELD) : this.relShield
	}
	getCurrentDmgReturn(consequences){
		return consequences ? this.dmgReturn+consequences.getAlteration(this, Stats.DMGRETURN) : this.dmgReturn
	}
	
	getCurrentEffect(item){
		return this.effects_items[item]
	}
	
	/*
	 * Actualise les informations de l'entité
	 */
	refresh() {
		// TODO make a real full refresh based on consequences? might be used for bulb?
		this.mp = getMP(this.id)
		this.cell = Map.getCell(getCell(this.id))
		this.reachableCells = this.getReachableCells(
			[this.cell:0],
			this.mp,
			this.cellsToIgnore
		)
	}
	
	/*
	 * Renvoie l'ensemble des cellules ou l'entité peut tirer sur la cellule ciblé avec l'arme/puce item
	 * @info La fonction prend en compte les LOS et toutes les autres entitées sauf l'Entity elle même (afin de ne pas prendre en compte les cases non accessibles) 
	 * à ne pas utiliser pour les bulbes 
	 * @param item Arme ou Puce de l'entité
	 * @param targetCell cellule ciblé par l'entité
	 * @return un tableau de cellules 
	 */
	getCellsToUseItemOnCell(item, targetCell){
		var leekToIgnore = [this.id],result = [], x = targetCell.x, y = targetCell.y
		if(item.isInLine){
			for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
				var dist = x-x1 < 0 ? x1-x : x-x1;
				if(dist < item.minRange) continue;
				var fromCell = Map.getCell(getCellFromXY(x1, y));
				if(fromCell!=null 
				&& Map.obstacles[fromCell]==null 
				&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
				&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
					push(result, fromCell);
				}
			}
			for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
				var dist = y-y1 < 0 ? y1-y : y-y1;
				if(dist < item.minRange) continue;
				var fromCell = Map.getCell(getCellFromXY(x, y1));
				if(fromCell!=null 
				&& Map.obstacles[fromCell]==null 
				&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
				&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}else{
			for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =(x-x1<0 ? x1-x : x-x1)+(y-y1<0 ? y1-y : y-y1);//trick pour abs(x-x1)+abs(y-y1)..
					if(dist > item.maxRange || dist < item.minRange) continue;
					var fromCell = Map.getCell(getCellFromXY(x1, y1));
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
					&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
						push(result, fromCell);
					}
				}
			}
		}
		return result;
	}
	
	/*
	 * Renvoie la cellule la plus proche ou l'entité peut tirer sur la cellule ciblée avec l'arme/puce item
	 * @info utilise les résultats de getCellsToUseItemOnCell puis détecte la cellule la plus proche parmis celles qui sont renvoyées 
	 * @param item Arme ou Puce de l'entité
	 * @param cell cellule ciblé par l'entité
	 * @return Cell
	 */	
	getCellToUseItemOnCell(item, cell){
		var cells = this.getCellsToUseItemOnCell(item, cell)
		var closestCell = null
		var tmpDist = 9999
		for(var c in cells){
			var distance = getCellDistance(this.cell, c)
			if(tmpDist > distance){
				tmpDist = distance
				closestCell = c
			}
		}
		return closestCell
	}

	/*
	 * Format chaîne de caracteres utilisée pour des tests / debugs.
	 */
	string() {
		return "<Entity "+this.name+">"
	}
}

// TODO

	//scoreLibe: scoreLibe
	//nbBulbs: count(bulbs)//todo check si ça vaut le coup de garder cette info..
	//bulbs: @bulbs
	//antidoteCD: inArray(getChips(leek), CHIP_ANTIDOTE) ? getCooldown(CHIP_ANTIDOTE) : 5
	//liberationCD: inArray(getChips(leek), CHIP_LIBERATION) ? getCooldown(CHIP_LIBERATION) : 6
	//canJump: inArray(getChips(leek), CHIP_JUMP) && getCooldown(CHIP_JUMP, leek)<=1
