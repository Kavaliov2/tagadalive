include('../auto')

/*
 *  Ensemble de méthodes et d'algorithmes permettant de calculer le Danger et les maps de dommages
 */
class MapDanger {
	static _danger = []
	static _cache_item_targetableCells = [] // [item:[fromCell:[targetCells]]]
	static _cache_allies_item_targetableCells = []
	static _map_entity_item_danger = [] // [e][item]
	
	/*
	 * Actualise les informations en fonctions des enemies et alliés encore vivant 
	 */
	static refresh(){
		_danger = []
		for(var e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [];//reset de la map
			e.offensiveItems = Items.getOrderedOffensiveItems(e)
			for(var item : var dmgPerTp in e.offensiveItems){
				_map_entity_item_danger[e][item] = MapDanger.getEnemiesDmgMap(e, item)
			}
		}
		_cache_allies_item_targetableCells = []
		for(var a in Fight.getAlliesAlive()){
			_map_entity_item_danger[a] = [];//reset de la map
			for(var e in Fight.getEnemiesAlive()){
				a.offensiveItemsByTargets[e] = Items.getOrderedOffensiveItems(a, e)
			}
			for(var offensiveItems in a.offensiveItemsByTargets){
				for(var item : var dmgPerTp in offensiveItems){
					_map_entity_item_danger[a][item] = MapDanger.getAlliesDmgMap(a, item)
				}
				break
			}
		}
	}
	
			/*
		 * Calcule le danger d'une Cell si elle n'a pas déjà été calculé.
		 * Pour chaque ennemis vivants somme les dommages de leurs items en fonction des TP et des temps de récupérations
		 * @param cell Cellule sur laquelle le danger va être calculé
		 * @return le tableau de Cell avec le danger mis à jour
		 */
	static getCellDanger(cell) {
		if(!_danger[cell]) {
			var dmg = 0
			var str = ""
			for(var e in Fight.getEnemiesAlive()){
				var tpleft = e.tp
				for(var item : var dmgPerTp in e.offensiveItems){
					var ratioDmg = _map_entity_item_danger[e][item][cell]
					var tmpdmg = MapDanger.getDamage(e, Fight.self, item)* ratioDmg
					if(tmpdmg>0){
						while(item.cost<=tpleft){
							str += item.name + " "
							dmg+=tmpdmg
							tpleft-=item.cost
							if(item.haveCD) break
						}
					}
				}
			}
			_danger[cell] = Danger(dmg, str)
		}
		return _danger[cell]
	}
		
		/*
		 * Retourune le combo avec potentiellement le plus de dommages que entity peux faire a l'ennemi sur la cellule cell
		 * @info pour l'instant c'est calculé en utilisant les données des dégats que je peux faire sur l'ennemi le plus proche
		 * @param entity Entity
		 * @param cell Cell de l'ennemie
		 * @return combo contenant le tableau d'actions et les dommages estimés
		 */
	static getPotentialCombo(entity, cell){
		var combo = Combo()
		var tpleft = entity.tp
		var inHand = entity.getWeaponInHand()
		var enemy = Fight.getEntity(getNearestEnemy())
		for(var item : var dmgPerTp in entity.offensiveItemsByTargets[enemy]){
			var ratioDmg = _map_entity_item_danger[entity][item][cell]
			var tmpdmg = MapDanger.getDamage(entity, Fight.getEntity(getEntityOnCell(cell)), item)* ratioDmg
			var switchCost = item.isWeap && item != inHand ? 1 : 0
			if(tmpdmg > 0){
				while(item.cost+switchCost<=tpleft){
					tpleft-=item.cost+switchCost
					if(switchCost==1){ inHand = item; switchCost = 0 }
					combo.add(Action(item, entity.getCellToUseItemOnCell(item, cell), cell))
					combo.dmg += tmpdmg
					if(item.haveCD) break
				}
			}
		}
		return combo
	}
	
		/*
		 * Calcule les dommages que peux faire entitySource sur entityTarget avec une Item en fonction des effets de celle-ci
		 * @param entitySource attaquant
		 * @param entityTarget receveur
		 * @param item Item
		 * @return dmg Dommages calculés
		 */
	static getDamage(entitySource, entityTarget, item){
		var dmg = 0;
		for(var e in item.effects){
			if(e.type == EFFECT_DAMAGE){
				var tmp = e.avgmax*(1+(entitySource.str/100))*(1+(entitySource.pwr/100));
				tmp = (tmp /* multiplier par laoe ratio ici*/ *(1-(entityTarget.relShield/100))) - entityTarget.absShield;
				dmg+= tmp;
			}
			else if(e.type == EFFECT_POISON){
				var duration = e.duration == 2 ? 1.8 : // TODO ces conversions devrait être dans des coefs globaux qqpart dans un scorings 
					(e.duration == 3 ? 2.4 :
					(e.duration == 4 ? 2.8 :
					e.duration));
				// TODO if(_CAN_ANTIDOTE) duration = 1;	
				dmg += e.avgmax*(1+(entitySource.mgc/100))*(1+(entitySource.pwr/100)) /* multiplier par laoe ratio ici*/ *duration;
			}
		}
		return dmg
	}
		
		/*
		 * Pour les cellules accessible par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
		 * @info cette fonction est appelé pour chaque items de l'allié
		 * @param ally Entity allié
		 * @item Item item
		 * @return map de Cells ciblables par l'Entity ally
		 */
	static getAlliesDmgMap(ally, item){
		var map = []//, map_mp = []
		for(var cell:var dist in ally.reachableCells){
			var targetableCells = MapDanger.getAlliesTargetableCells(item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}
		/*
		 * Retourne les Cells pouvant être touché avec le parametre item par les alliés, la fonction est appelé pour chaque cellule accessible
		 * Hum... =(
		 * ++++++++++[>+>+++>+++++++>++++++++++<<<<-]>>>>-.<<+++++++++.>>++.++++++++++++++.+.<<-------.>>---.++++.--------------------.+++++++++++++.----------.<<.>>+++++++++.--------.++++++++.--------.<<.>>+++++++++++.---------------.++++++++++++++++++.<<.>>+.--.-------------.++++++++++++++.<<.>>----------------.+++++++++.-----------.++++++++.+++++++++.<<.>---------.<++++++++.
		 * @see  https://fr.wikipedia.org/wiki/Brainfuck
		 * @param item Item
		 * @param cell une Cellule accesible par l'entité en question
		 * @TODO corriger le commentaire
		 * @return cache sous forme de double tableau
		 */
	static getAlliesTargetableCells(item, cell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(_cache_allies_item_targetableCells[item]==null) _cache_allies_item_targetableCells[item] = []
		if(MapDanger._cache_allies_item_targetableCells[item][cell]==null){
			var result = [], x = cell.x, y = cell.y
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist =((x-x1)<0?x1-x:x-x1);
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x1, y));
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
						push(result, targetCell);
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =((y-y1)<0?y1-y:y-y1);
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x, y1));
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
						push(result, targetCell);
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist =((x-x1)<0?x1-x:x-x1)+(y-y1<0?y1-y:y-y1);//trick pour abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var targetCell = Map.getCell(getCellFromXY(x1, y1));
						if(targetCell!=null 
						&& Map.obstacles[targetCell]==null 
						&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
							push(result, targetCell);
						}
					}
				}
			}
			MapDanger._cache_allies_item_targetableCells[item][cell]= result;
		}
		return MapDanger._cache_allies_item_targetableCells[item][cell];
	}
		
		
		/*
		 * Pour les cellules accessible par l'ennemi, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
		 * @info cette fonction est appelé pour chaque items de l'ennemi'
		 * @param enemy Entity ennemi
		 * @item Item item
		 * @return map de Cells ciblables par l'Entity enemy
		 */
	static getEnemiesDmgMap(enemy, item){
		var map = []//, map_mp = []
		for(var cell:var dist in enemy.reachableCells){
			var targetableCells = MapDanger.getEnemiesTargetableCells(item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1;//coef
					//map_mp[c]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}
	
		/*
		 * Retourne les Cells pouvant être touché avec le parametre item par les ennemis, la fonction est appelé pour chaque cellule accessible
		 * @see getAlliesTargetableCells
		 * @param item Item
		 * @param cell une Cellule accesible par l'entité en question
		 */
	// TODO memoisé lineOfSight ignoring allEntitiesId
	// fonction avec cache qui considère que los est tjr pareil.
	static getEnemiesTargetableCells(item, cell){
		// init du cache si nécessaire
		if(_cache_item_targetableCells[item]==null) _cache_item_targetableCells[item] = []
		if(MapDanger._cache_item_targetableCells[item][cell]==null){
			var result = [], x = cell.x, y = cell.y
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist =((x-x1)<0?x1-x:x-x1);
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x1, y));
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
						push(result, targetCell);
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =((y-y1)<0?y1-y:y-y1);
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x, y1));
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
						push(result, targetCell);
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist =((x-x1)<0?x1-x:x-x1)+(y-y1<0?y1-y:y-y1);//trick pour abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var targetCell = Map.getCell(getCellFromXY(x1, y1));
						if(targetCell!=null 
						&& Map.obstacles[targetCell]==null 
						&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
							push(result, targetCell);
						}
					}
				}
			}
			MapDanger._cache_item_targetableCells[item][cell]= result;
		}
		return MapDanger._cache_item_targetableCells[item][cell];
	}

}