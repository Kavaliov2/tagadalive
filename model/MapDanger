include('../auto')

/*
 *  Ensemble de méthodes et d'algorithmes permettant de calculer le Danger et les maps de dommages
 */
class MapDanger {
	// cache du danger estimé sur la case, reset à chaque tour, pour la v1 du danger, sera amener à évoluer quand on améliorera la map
	static _danger = [] // [cell:danger]
	
	// cache contenant pour chaque item, pour chaque case, les cases qu'on peut toucher si rien ne bloque la LOS
	// ne doit pas être reset en début de tour, l'info reste valide, et est lazyloader à la demande.
	static _cache_item_targetableCells = [] // [item:[fromCell:[targetCells]]]
	
	// cache contenant pour chaque ally, pour chaque item, pour chauqe case, les cases qu'on peut toucher, en prenant en compte la LOS
	// doit être refresh à chaque tour, car on prend en compte la LOS
	// TODO faire des tests de performances quand on rencontrera des problèmes d'opérations, c'est surement nettement + couteux...
	static _cache_allies_item_targetableCells = [] // [ally:[item:[fromCell:[targetCells]]]]
	
	// cache pour chaque enemy des maps des cases où il peut tirer
	// refresh à chaque tour
	static _map_entity_item_danger = [] // [e][item:ratio]
	
	/*
	 * Actualise les informations en fonctions des enemies et alliés encore vivant 
	 */
	static refresh(){
		// reset du cache
		_danger = []
		_map_entity_item_danger = []
		// pour chaque adv
		for(var e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [];//reset de la map
			e.offensiveItems = Items.getOrderedOffensiveItems(e)
			// pour chaque item offensif
			for(var item : var dmgPerTp in e.offensiveItems){
				// on trouve les cases qu'il peut toucher avec son item
				_map_entity_item_danger[e][item] = MapDanger.getEnemiesDmgMap(e, item)
			}
		}
		_cache_allies_item_targetableCells = []
		// pour chaque ally
		for(var a in Fight.getAlliesAlive()){
			_map_entity_item_danger[a] = [];//reset de la map
			for(var e in Fight.getEnemiesAlive()){
				// on récup les items offensif pour chaque adv
				a.offensiveItemsByTargets[e] = Items.getOrderedOffensiveItems(a, e)
			}
			// pour chaque set d'items, chaque item, on récup la map des cases touchables
			for(var offensiveItems in a.offensiveItemsByTargets){
				for(var item : var dmgPerTp in offensiveItems){
					_map_entity_item_danger[a][item] = MapDanger.getAlliesDmgMap(a, item)
				}
				break
			}
		}
	}
	
	/*
	 * Calcule le danger d'une Cell, version sans Conséquences
	 * @param <Cell> cell la case sur laquel on veut le danger
	 * @return <Danger>
	 */
	static getCellDanger(cell){
		return MapDanger.getCellDanger(cell, null)
	}
		
	/*
	 * TODO gestion des consequences
	 * Calcule le danger d'une Cell si elle n'a pas déjà été calculé.
	 * Pour chaque ennemis vivants somme les dommages de leurs items en fonction des TP et des temps de récupérations
	 * @param cell Cellule sur laquelle le danger va être calculé
	 * @return le tableau de Cell avec le danger mis à jour
	 */
	static getCellDanger(cell, consequences) {
		if(!_danger[cell]) {
			var dmg = 0
			var str = ""
			for(var e in Fight.getEnemiesAlive()){
				var tpleft = e.tp
				for(var item : var dmgPerTp in e.offensiveItems){
					var ratioDmg = _map_entity_item_danger[e][item][cell]
					var tmpdmg = MapDanger.getDamage(e, Fight.self, item)* ratioDmg
					if(tmpdmg>0){
						while(item.cost<=tpleft){
							str+=" "+item.name
							dmg+=tmpdmg
							tpleft-=item.cost
							if(item.haveCD) break
						}
					}
				}
			}
			_danger[cell] = Danger(cell, dmg, str)
		}
		return _danger[cell]
	}
		
	/*
	 * Premier exemple d'algo naif où je cherche uniquement à maximiser les dégats sur nearest enemy
	 * @param entity Entity
	 * @param cell Cell de l'ennemie
	 * @return combo contenant le tableau d'actions et les dommages estimés
	 */
	static getPotentialCombo(entity, cell){
		var combo = Combo()
		var tpleft = entity.tp
		var inHand = entity.getWeaponInHand()
		var enemy = Fight.getEntity(getNearestEnemy())
		for(var item : var dmgPerTp in entity.offensiveItemsByTargets[enemy]){
			var ratioDmg = _map_entity_item_danger[entity][item][cell]
			var tmpdmg = MapDanger.getDamage(entity, Fight.getEntity(getEntityOnCell(cell)), item)* ratioDmg
			var switchCost = item.isWeap && item != inHand ? 1 : 0
			if(tmpdmg > 0){
				while(item.cost+switchCost<=tpleft){
					tpleft-=item.cost+switchCost
					if(switchCost==1){ inHand = item; switchCost = 0 }
					combo.add(Action(item, entity.getCellToUseItemOnCell(item, cell), cell))
					if(item.haveCD) break
				}
			}
		}
		return combo
	}
	
	/*
	 * Premier exemple d'algo naif de recherche de case de fin de tour
	 * je minimise les dégats, puis à danger équivalent je choisi la case la plus proche de l'adversaire
	 */
	static findBestDanger(from, mpleft){
		var shouldGetCloseTo = Fight.getEntity(getNearestEnemy()).cell
		var bestDanger = null
		// depuis la case @from, avec les mp restant
		var reachableCells = Fight.self.getReachableCells([from:0], mpleft, Fight.self.cellsToIgnore)
		for(var cell:var mp in reachableCells){
			var danger = MapDanger.getCellDanger(cell)
			if(!bestDanger || bestDanger.dmg > danger.dmg) {
				bestDanger = danger
			} else if(bestDanger.dmg == danger.dmg){
				// en cas de danger équivalent, je m'approche le plus possible de l'adv
				if(getCellDistance(shouldGetCloseTo, bestDanger.cell) > getCellDistance(shouldGetCloseTo, danger.cell)){
					bestDanger = danger
				}
			}
		}
		return bestDanger
	}

	
	/*
	 * Calcule les dommages que peux faire entitySource sur entityTarget avec une Item en fonction des effets de celle-ci
	 * @param entitySource attaquant
	 * @param entityTarget receveur
	 * @param item Item
	 * @return dmg Dommages calculés
	 */
	static getDamage(entitySource, entityTarget, item){
		var dmg = 0;
		for(var e in item.effects){
			if(e.type == EFFECT_DAMAGE){
				var tmp = e.avgmax*(1+(entitySource.str/100))*(1+(entitySource.pwr/100));
				tmp = (tmp /* multiplier par laoe ratio ici*/ *(1-(entityTarget.relShield/100))) - entityTarget.absShield;
				dmg+= max(tmp, 0)
			}
			else if(e.type == EFFECT_POISON){
				var duration = e.duration == 2 ? 1.8 : // TODO ces conversions devrait être dans des coefs globaux qqpart dans un scorings 
					(e.duration == 3 ? 2.4 :
					(e.duration == 4 ? 2.8 :
					e.duration));
				// TODO if(_CAN_ANTIDOTE) duration = 1;	
				dmg += e.avgmax*(1+(entitySource.mgc/100))*(1+(entitySource.pwr/100)) /* multiplier par laoe ratio ici*/ *duration;
			}
		}
		return dmg
	}
		
	/*
	 * Pour les cellules accessible par l'allié, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'allié
	 * @param ally Entity allié
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity ally
	 */
	static getAlliesDmgMap(ally, item){
		var map = []//, map_mp = []
		for(var cell:var dist in ally.reachableCells){
			var targetableCells = MapDanger.getAlliesTargetableCells(item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}

	/*
	 * Retourne les Cells pouvant être touché depuis la @cell avec l'@item par les alliés
	 * Hum... =(
	 * ++++++++++[>+>+++>+++++++>++++++++++<<<<-]>>>>-.<<+++++++++.>>++.++++++++++++++.+.<<-------.>>---.++++.--------------------.+++++++++++++.----------.<<.>>+++++++++.--------.++++++++.--------.<<.>>+++++++++++.---------------.++++++++++++++++++.<<.>>+.--.-------------.++++++++++++++.<<.>>----------------.+++++++++.-----------.++++++++.+++++++++.<<.>---------.<++++++++.
	 * @see  https://fr.wikipedia.org/wiki/Brainfuck
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 * @TODO corriger le commentaire
	 * @return cache sous forme de double tableau
	 */
	static getAlliesTargetableCells(item, cell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(MapDanger._cache_allies_item_targetableCells[item]==null) MapDanger._cache_allies_item_targetableCells[item] = []
		if(MapDanger._cache_allies_item_targetableCells[item][cell]==null){
			var result = [], x = cell.x, y = cell.y
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist = x-x1<0?x1-x:x-x1
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x1, y))
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
						push(result, targetCell)
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist = y-y1<0?y1-y:y-y1
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x, y1))
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
						push(result, targetCell)
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist =(x-x1<0?x1-x:x-x1)+(y-y1<0?y1-y:y-y1) // abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var targetCell = Map.getCell(getCellFromXY(x1, y1));
						if(targetCell!=null 
						&& Map.obstacles[targetCell]==null 
						&& (!item.needLOS || lineOfSight(cell, targetCell, []))){
							push(result, targetCell);
						}
					}
				}
			}
			MapDanger._cache_allies_item_targetableCells[item][cell]= result;
		}
		return MapDanger._cache_allies_item_targetableCells[item][cell];
	}
		
		
	/*
	 * Pour les cellules accessible par l'ennemi, initialise un tableau contenant les cases qu'il peut cibler avec l'item passé en paramètre
	 * @info cette fonction est appelé pour chaque items de l'ennemi'
	 * @param enemy Entity ennemi
	 * @item Item item
	 * @return map de Cells ciblables par l'Entity enemy
	 */
	static getEnemiesDmgMap(enemy, item){
		var map = []//, map_mp = []
		for(var cell:var dist in enemy.reachableCells){
			var targetableCells = MapDanger.getEnemiesTargetableCells(item, cell);
			for(var c in targetableCells){
				if(map[c]==null){
					map[c]=1;//coef
					//map_mp[c]=dist;
				}
			}
		}
		
		//aoe TODO AREA_PLUS_, AREA_X_, AREA_SQUARE_
		if(item.area==AREA_CIRCLE_1 || item.area==AREA_CIRCLE_2 || item.area==AREA_CIRCLE_3){
			for(var distance = 1; distance<=item.area-2; distance++){ // ici trick pour réduire les opé, par du principe que AREA_CIRCLE_1 = 3 et AREA_CIRCLE_3 = 5
				var ratio = 1 - 0.2 * distance
				if(ratio ==0) break;
				var circle = [];
				for(var c:var value in map){
					if(value>0)
						for(var cell in c.neighborsObstacles)
							if(map[cell]==null || map[cell]==0) push(circle, cell);
				}
				for(var cell in circle){
					map[cell] = ratio;
					//map_mp[cell] = eMp;
				}
			}
		}
		
		return map // TODO add map_mp
	}
	
	/*
	 * Retourne les Cells pouvant être touché avec le parametre item par les ennemis, la fonction est appelé pour chaque cellule accessible
	 * @see getAlliesTargetableCells
	 * @param item Item
	 * @param cell une Cellule accesible par l'entité en question
	 */
	// TODO memoisé lineOfSight ignoring allEntitiesId
	// fonction avec cache qui considère que los est tjr pareil.
	static getEnemiesTargetableCells(item, cell){
		// init du cache si nécessaire
		if(MapDanger._cache_item_targetableCells[item]==null) MapDanger._cache_item_targetableCells[item] = []
		if(MapDanger._cache_item_targetableCells[item][cell]==null){
			var result = [], x = cell.x, y = cell.y
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist = x-x1<0?x1-x:x-x1
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x1, y))
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
						push(result, targetCell);
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist = y-y1<0?y1-y:y-y1
					if(dist < item.minRange) continue;
					var targetCell = Map.getCell(getCellFromXY(x, y1))
					if(targetCell!=null 
					&& Map.obstacles[targetCell]==null 
					&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
						push(result, targetCell);
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist = (x-x1<0?x1-x:x-x1)+(y-y1<0?y1-y:y-y1) // abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var targetCell = Map.getCell(getCellFromXY(x1, y1))
						if(targetCell!=null 
						&& Map.obstacles[targetCell]==null 
						&& (!item.needLOS || lineOfSight(cell, targetCell, Fight.allEntitiesId))){
							push(result, targetCell);
						}
					}
				}
			}
			MapDanger._cache_item_targetableCells[item][cell]= result;
		}
		return MapDanger._cache_item_targetableCells[item][cell];
	}
		
	static showDanger(from, mpleft) {
		var reachableCells = Fight.self.getReachableCells([from:0], mpleft, Fight.self.cellsToIgnore)
		var arrayDanger = []
		for(var c : var d in reachableCells) {
			var danger = MapDanger.getCellDanger(c)
			var red = (danger.dmg*255)/Fight.self.life
			if(red>255) mark(c.id, getColor(0, 0, 0))
			else mark(c.id, getColor(red, 255-red, 0))
			markText(c.id, round(danger.dmg))
			arrayDanger[round(danger.dmg)] = danger
		}
		for(var danger in arrayDanger){
			debug(danger)
		}
	}

}