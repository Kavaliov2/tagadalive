include('../auto')

class MapDanger {
	static _danger = []
	static _cache_item_targetableCells = [] // [item:[fromCell:[targetCells]]]
	static _cache_allies_item_targetableCells = []
	static _map_entity_item_danger = [] // [e][item]
	
	static init(){
		_danger = []
		for(var e in Fight.getEnemiesAlive()){
			_map_entity_item_danger[e] = [];//reset de la map
			e.offensiveItems = Items.getOrderedOffensiveItems(e.id)
			for(var item : var dmgPerTp in e.offensiveItems){
				_map_entity_item_danger[e][item] = MapDanger.getEnemiesDmgMap(e, item)
			}
		}
		_cache_allies_item_targetableCells = []
		for(var a in Fight.getAlliesAlive()){
			_map_entity_item_danger[a] = [];//reset de la map
			for(var e in Fight.getEnemiesAlive()){
				a.offensiveItemsByTargets[e] = Items.getOrderedOffensiveItems(a.id, e)
			}
			for(var offensiveItems in a.offensiveItemsByTargets){
				for(var item : var dmgPerTp in offensiveItems){
					_map_entity_item_danger[a][item] = MapDanger.getAlliesDmgMap(a, item)
				}
				break
			}
		}
	}
	
	static getCellDanger(cell) {
		if(!_danger[cell]) {
			var dmg = 0
			var str = ""
			for(var e in Fight.getEnemiesAlive()){
				var tpleft = e.tp
				for(var item : var dmgPerTp in e.offensiveItems){
					var ratioDmg = _map_entity_item_danger[e][item][cell]
					var tmpdmg = MapDanger.getDamage(e, Fight.self, item)* ratioDmg
					if(tmpdmg>0){
						while(item.cost<=tpleft){
							str += item.name + " "
							dmg+=tmpdmg
							tpleft-=item.cost
							if(item.haveCD) break
						}
					}
				}
			}
			_danger[cell] = Danger(dmg, str)
		}
		return _danger[cell]
	}
		
	static getPotentialCombo(entity, cell){
		var combo = Combo()
		var tpleft = entity.tp
		var enemy = Fight.getEntity(getNearestEnemy())
		for(var item : var dmgPerTp in entity.offensiveItemsByTargets[enemy]){
			var ratioDmg = _map_entity_item_danger[entity][item][cell.id]
			var tmpdmg = MapDanger.getDamage(entity, Fight.getEntity(getEntityOnCell(cell.id)), item)* ratioDmg
			if(tmpdmg > 0){
				while(item.cost<=tpleft){
					tpleft-=item.cost
					combo.add(Action(item, Map.getCell(entity.getCellToUseItemOnCell(item, cell)), cell))
					combo.dmg += tmpdmg
					if(item.haveCD) break
				}
			}
		}
		return combo
	}
	
	static getDamage(entitySource, entityTarget, item){
		var dmg = 0;
		for(var e in item.effects){
			if(e.type == EFFECT_DAMAGE){
				var tmp = e.avgmax*(1+(entitySource.str/100))*(1+(entitySource.pwr/100));
				tmp = (tmp /* multiplier par laoe ratio ici*/ *(1-(entityTarget.relShield/100))) - entityTarget.absShield;
				dmg+= tmp;
			}
			else if(e.type == EFFECT_POISON){
				var duration = e.duration == 2 ? 1.8 : // 2 => 1
					(e.duration == 3 ? 2.4 : // 3 => 1.25
					(e.duration == 4 ? 2.8 : // 4 => 1.5
					e.duration)); // 1 => 1
				// TODO if(_CAN_ANTIDOTE) duration = 1;	
				dmg += e.avgmax*(1+(entitySource.mgc/100))*(1+(entitySource.pwr/100)) /* multiplier par laoe ratio ici*/ *duration;
			}
		}
		return dmg
	}
		
	static getAlliesDmgMap(enemy, item){
		var map = []//, map_mp = []
		for(var idCell:var dist in enemy.reachableCells){
			var targetableCells = MapDanger.getAlliesTargetableCells(item, idCell);
			for(var cell in targetableCells){
				if(map[cell]==null){
					map[cell]=1;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}
		
	static getAlliesTargetableCells(item, idCell){ // TODO add ignoreleeks to ignore leeks who play before
		// init du cache si nécessaire
		if(_cache_allies_item_targetableCells[item.id]==null) _cache_allies_item_targetableCells[item.id] = []
		if(MapDanger._cache_allies_item_targetableCells[item.id][idCell]==null){
			var result = [], x = getCellX(idCell), y = getCellY(idCell)
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist =((x-x1)<0?-(x-x1):x-x1);
					if(dist < item.minRange) continue;
					var fromCell = getCellFromXY(x1, y);
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& Map.entityCells[fromCell]==null
					&& (!item.needLOS || lineOfSight(fromCell, idCell, []))){
						push(result, fromCell);
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =((y-y1)<0?-(y-y1):y-y1);
					if(dist < item.minRange) continue;
					var fromCell = getCellFromXY(x, y1);
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& Map.entityCells[fromCell]==null
					&& (!item.needLOS || lineOfSight(fromCell, idCell, []))){
						push(result, fromCell);
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist =((x-x1)<0?-(x-x1):x-x1)+(y-y1<0?-(y-y1):y-y1);//trick pour abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var fromCell = getCellFromXY(x1, y1);
						if(fromCell!=null 
						&& Map.obstacles[fromCell]==null 
						&& Map.entityCells[fromCell]==null
						&& (!item.needLOS || lineOfSight(fromCell, idCell, []))){
							push(result, fromCell);
						}
					}
				}
			}
			MapDanger._cache_allies_item_targetableCells[item.id][idCell]= result;
		}
		return MapDanger._cache_allies_item_targetableCells[item.id][idCell];
	}
		
	static getEnemiesDmgMap(enemy, item){
		var map = []//, map_mp = []
		for(var idCell:var dist in enemy.reachableCells){
			var targetableCells = MapDanger.getEnemiesTargetableCells(item, idCell);
			for(var cell in targetableCells){
				if(map[cell]==null){
					map[cell]=1;//coef
					//map_mp[cell]=dist;
				}
			}
		}
		//aoe TODO
		
		return map // TODO add map_mp
	}
	
	// TODO memoisé lineOfSight ignoring allEntitiesId
	// fonction avec cache qui considère que los est tjr pareil.
	static getEnemiesTargetableCells(item, idCell){
		// init du cache si nécessaire
		if(_cache_item_targetableCells[item.id]==null) _cache_item_targetableCells[item.id] = []
		if(MapDanger._cache_item_targetableCells[item.id][idCell]==null){
			var result = [], x = getCellX(idCell), y = getCellY(idCell)
			if(item.isInLine){
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					var dist =((x-x1)<0?-(x-x1):x-x1);
					if(dist < item.minRange) continue;
					var fromCell = getCellFromXY(x1, y);
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& Map.entityCells[fromCell]==null
					&& (!item.needLOS || lineOfSight(fromCell, idCell, Fight.allEntitiesId))){
						push(result, fromCell);
					}
				}
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =((y-y1)<0?-(y-y1):y-y1);
					if(dist < item.minRange) continue;
					var fromCell = getCellFromXY(x, y1);
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& Map.entityCells[fromCell]==null
					&& (!item.needLOS || lineOfSight(fromCell, idCell, Fight.allEntitiesId))){
						push(result, fromCell);
					}
				}
			}else{
				for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
					for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
						var dist =((x-x1)<0?-(x-x1):x-x1)+(y-y1<0?-(y-y1):y-y1);//trick pour abs(x-x1)+abs(y-y1)..
						if(dist > item.maxRange || dist < item.minRange) continue;
						var fromCell = getCellFromXY(x1, y1);
						if(fromCell!=null 
						&& Map.obstacles[fromCell]==null 
						&& Map.entityCells[fromCell]==null
						&& (!item.needLOS || lineOfSight(fromCell, idCell, Fight.allEntitiesId))){
							push(result, fromCell);
						}
					}
				}
			}
			MapDanger._cache_item_targetableCells[item.id][idCell]= result;
		}
		return MapDanger._cache_item_targetableCells[item.id][idCell];
	}

}