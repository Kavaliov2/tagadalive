include('../auto')

class Entity {
	id
	name
	cell
	totalLife
	life
	lifeMissing
	effects
	pwr
	str
	mgc
	wsd
	rst
	agi
	snc
	tp
	mp
	relShield
	absShield
	dmgReturn
	reachableCells
	items
	offensiveItems // on enemy leeks only
	offensiveItemsByTargets = [] // on ally leeks only
	turnOrder
	entityWhoPlayBefore
	cellsToIgnore = []
	
	constructor(id){
		this.id = id
		this.name = getName(id)
		this.cell = Map.getCell(getCell(id))
		this.totalLife = getTotalLife(id)
		this.life = getLife(id)
		this.lifeMissing = this.totalLife - this.life
		this.effects = getEffects(id)
		this.pwr = getPower(id)
		this.str = getStrength(id)
		this.mgc = getMagic(id)
		this.wsd = getWisdom(id)
		this.rst = getResistance(id)
		this.agi = getAgility(id)
		this.snc = getScience(id)
		this.tp = getTP(id)
		this.mp = getMP(id)
		this.relShield = getRelativeShield(id)
		this.absShield = getAbsoluteShield(id)
		this.dmgReturn = getDamageReturn(id)
		this.items = Items.getItems(id)
		this.turnOrder = getEntityTurnOrder(id)
	}

	init(){
		this.entityWhoPlayBefore = Fight.getListOfLeekWhoPlayBefore(this)
		for(var entity in this.entityWhoPlayBefore) {
			push(this.cellsToIgnore, entity.cell)
		}
		this.reachableCells = this.getReachableCells(
			[this.cell:0],
			this.mp,
			this.cellsToIgnore
		)
	}
	
	getWeaponInHand(){
		return Items.getItem(getWeapon(this))
	}

	// return reachable cell as an array of [cell:dist]
	// cells must be in form : [cell:dist]
	getReachableCells(cells, mp, ignoreCells){
		var stack = cells;
		var tmp = cells;
		var next = [];
		while(mp-->0){
			for(var currentWorkingCell: var dist in tmp){
				for(var c in currentWorkingCell.neighbors){
					if(stack[c] == null && (isEmptyCell(c) || inArray(ignoreCells, c))){
						stack[c] = dist+1;
						next[c] = dist+1;
					}
				}
			}
			tmp = next;
			next = [];
		}
		return stack
	}
	
	refresh() {
		// TODO all
		this.mp = getMP(this.id)
		this.cell = Map.getCell(getCell(this.id))
		this.reachableCells = this.getReachableCells(
			[this.cell:0],
			this.mp,
			Fight.getListOfLeekWhoPlayBefore(this)
		)
	}
	
	// renvoie un array de cell depuis lesquel on peut tirer sur cell
	// pour les lignes de vue et _LEEKS pour les cases non accessibles (ou il y a tout le monde sauf le leek)
	// donc pas pour les bulbes cette fonction !
	getCellsToUseItemOnCell(item, targetCell){
		var leekToIgnore = [this.id],result = [], x = targetCell.x, y = targetCell.y
		if(item.isInLine){
			for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
				var dist =((x-x1)<0?x1-x:x-x1);
				if(dist < item.minRange) continue;
				var fromCell = Map.getCell(getCellFromXY(x1, y));
				if(fromCell!=null 
				&& Map.obstacles[fromCell]==null 
				&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
				&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
					push(result, fromCell);
				}
			}
			for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
				var dist =((y-y1)<0?y1-y:y-y1);
				if(dist < item.minRange) continue;
				var fromCell = Map.getCell(getCellFromXY(x, y1));
				if(fromCell!=null 
				&& Map.obstacles[fromCell]==null 
				&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
				&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}else{
			for(var x1 = x-item.maxRange; x1 <= x+item.maxRange; x1++){
				for(var y1 = y-item.maxRange; y1 <= y+item.maxRange; y1++){
					var dist =((x-x1)<0?x1-x:x-x1)+(y-y1<0?y1-y:y-y1);//trick pour abs(x-x1)+abs(y-y1)..
					if(dist > item.maxRange || dist < item.minRange) continue;
					var fromCell = Map.getCell(getCellFromXY(x1, y1));
					if(fromCell!=null 
					&& Map.obstacles[fromCell]==null 
					&& (Map.entityCells[fromCell]==null || Map.entityCells[fromCell]==Fight.self)
					&& (!item.needLOS || lineOfSight(fromCell, targetCell, leekToIgnore))){
						push(result, fromCell);
					}
				}
			}
		}
		return result;
	}
		
	getCellToUseItemOnCell(item, cell){
		var cells = this.getCellsToUseItemOnCell(item, cell)
		var closestCell = null
		var tmpDist = 9999
		for(var c in cells){
			var distance = getCellDistance(this.cell, c)
			if(tmpDist > distance){
				tmpDist = distance
				closestCell = c
			}
		}
		return closestCell
	}

	string() {
		return "<Entity "+this.name+">"
	}
}

// TODO

	//psnlife: getLife(leek)-psnDmgTurn
	//psnTurn: psnDmgTurn
	//psnTotal: psnDmgTotal
	//alterateStr: alterateStr
	//alterateMgc: alterateMgc
	//alterateTP: alterateTP
	//alterateMP: alterateMP
	//alterateAgi: alterateAgi
	//scoreLibe: scoreLibe
	//nbBulbs: count(bulbs)//todo check si ça vaut le coup de garder cette info..
	//bulbs: @bulbs
	//order: enemyOrder[leek]
	//antidoteCD: inArray(getChips(leek), CHIP_ANTIDOTE) ? getCooldown(CHIP_ANTIDOTE) : 5
	//liberationCD: inArray(getChips(leek), CHIP_LIBERATION) ? getCooldown(CHIP_LIBERATION) : 6
	//canJump: inArray(getChips(leek), CHIP_JUMP) && getCooldown(CHIP_JUMP, leek)<=1
