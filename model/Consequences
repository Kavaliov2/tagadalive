include('../auto')

class Consequences {
	_alterations = []// [entity:[caracteristic:value]]
	_killed = []
	score = null
	isAlteringDanger = false
	hashcode = 17
	
	static HP 			= 0
	static HPTIME		= 1
	static HPMAX		= 2
	static DEBUFF 		= 3
	static ANTIDOTE 	= 4
	static ABSSHIELD 	= 5
	static RELSHIELD 	= 6
	static DMGRETURN 	= 7
	static STR 			= 8
	static MGC 			= 9
	static RST 			= 10
	static WSD 			= 11
	static AGI 			= 12
	static TP 			= 13
	static MP	 		= 14
	static PWR			= 15
	
	static KILL			= 16
	
	constructor(action){
		construct(action)
	}
	
	constructor(action, consequences){
		this._alterations = clone(consequences._alterations, 2)
		this._killed = clone(consequences._killed)
		this.hashcode = consequences.hashcode
		construct(action)
	}
	
	construct(action){
		var targets
		if(action.to == Fight.selfCell) targets = [Fight.self.id] 
		else targets = getItemTargets(action.item, action.to)
		// FIXME itemTargets return null when i dont have the item ?
		for(var targetId in targets){
			var target = Fight.getEntity(targetId)
			if(this._killed[target]) continue
			var ratioDmg = 1-(0.2*getCellDistance(action.to, target.cell))
			if(ratioDmg<=0){
				debugE('Bug in Consequences constructor, SHOULD NOT HAPPEN !')
				continue
			}
			for(var effect in action.item.effects) {
				effect.updateConsequences(Fight.self, target, ratioDmg, this)
			}
		}
	}
	
	add(entity, key, value){
		if(!_alterations[entity]) _alterations[entity] = []
		_alterations[entity][key] += value // pour null, devrait se comporter comme si ça contenait 0
			// ça ne marche qu'avec += en leekscriptv1, pas tester en v1.1 comment ça marche...
			// j'avais des bugs sur les -=, donc il faut faire += -value si le comportement est le mm ici.
		
		if(entity==Fight.self && (
			   key==Consequences.HP
			|| key==Consequences.ABSSHIELD
			|| key==Consequences.RELSHIELD
			|| key==Consequences.DEBUFF)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + (value|0)
		} else if(!entity.isFriend && (
			   key==Consequences.DEBUFF
			|| key==Consequences.STR
			|| key==Consequences.TP
			|| key==Consequences.MP)){
				this.isAlteringDanger=true
				this.hashcode = 31 * this.hashcode + entity.id
				this.hashcode = 31 * this.hashcode + (value|0)
		}

		// update du score
		this.score+= value * Scoring.getCoef(entity, key)
	}
	
	add(entity, key){
		if(key == Consequences.KILL){
			this.isAlteringDanger=true
			this.hashcode = 31 * this.hashcode + entity.id
			this._killed[entity]=true
			this.score+= Scoring.KILL_VALUE * Scoring.getCoef(entity, key)
		} else {
			debugW('called Consequences.add() with wrong key or value')
		}
	}
	
	getAlterations(){
		return _alterations
	}
		
	isKilled(entity){
		return _killed[entity]
	}
	
	getAlteration(entity, key){
		return _alterations[entity][key]
	}
	
	getScore(){
		return this.score
	}
	
	computeScore(){
		var totalScore = 0;
		for(var entity:var key in this._alterations){
			var value = this.getAlteration(entity, key)
			if(key == Consequences.HP) 			totalScore+= entity.isFriend ? value : -value
			if(key == Consequences.ABSSHIELD) 	totalScore+= entity.isFriend ? value*3 : -(value*3)
			if(key == Consequences.STR) 		totalScore+= entity.isFriend ? value : -value
			
		}
		for(var entity:var bool in this._killed){
			var killScore = 10000
			killScore*= entity.isBulb ? 0.5 : 1
			totalScore+= entity.isFriend ? -killScore : killScore
		}
		return totalScore
	}
	
	string(){
		var str = "<Consequences"
		for(var entity:var alteration in this._alterations){
			str+= "\n" + entity.name + ":"
			for(var key:var value in alteration){
				if(key == Consequences.HP) 			str+= "|HP: "+round(value)
				if(key == Consequences.ABSSHIELD) 	str+= "|ABSSHIELD: "+round(value)
				if(key == Consequences.STR) 		str+= "|STR: "+round(value)
			}
		}
		for(var entity:var isDead in this._killed) str+= "\n|KILL: "+ entity
		str+="\nhashcode:"+this.hashcode+">"
		return str
	}
}