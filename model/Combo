include('../auto')

/*
 * Ensemble d'actions formant un combo 
 * L'objet combo contient les dommages approximatifs calculé dans MapDanger::getPotentialCombo
 */
class Combo {
	actions = []
	finalDanger = null
	score = null
	
	/*
	 * Ajout d'action dans l'ensemble d'actions du combo
	 * @param action Action a ajouter dans le combo
	 */
	add(action){
		if(count(this.actions) == 0) push(this.actions, action)
		else {
			var actualized = Action(action, this.getCurrentConsequences())
			if(actualized.score > 0) push(this.actions, actualized)
			else return false
		}
		return true
	}
	
	addFinalDanger(cell){
		this.finalDanger = cell
	}
	
	/*
	 * retourne la somme des scores des actions du combo
	 */
	getScore(){
		if(this.score === null){
			for(var action in this.actions){
				this.score+= action.score
			}
			this.score+= this.finalDanger.score
		}
		return this.score
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	getCurrentCell(){
		var currentCell
		if(this.finalDanger) currentCell = this.finalDanger.cell
		else if(count(this.actions)>0) currentCell = actions[count(this.actions)-1].from
		else currentCell = Fight.self.cell

		if(currentCell == Fight.selfCell) currentCell = Fight.self.cell
		return currentCell
	}
	
	/*
	 * retourne la cell où on serait si on jouait le combo en l'état
	 */
	getCurrentConsequences(){
		if(count(this.actions)>0) return actions[count(this.actions)-1].consequences
		else return null
	}
	
	/*
	 * retourne les reachableCells atteignable depuis l'emplacement actuel du combo
	 */
	getCurrentReachableCells(){
		var from = this.getCurrentCell()
		// FIXME : ici je pars du principe que le seul chemin parcouru est depuis ma cell de début et currentCell
		// TODO: this.getCurrentMP() qui simule les déplacements entre les actions.
		// voir plutôt avoir une variable currentCell et currentMP que j'actualise à chaque ajout d'action.
		var mpleft = Fight.self.mp - Fight.self.reachableCells[from]
		return Fight.self.getReachableCells([from:0], mpleft, Fight.self.cellsToIgnore)
	}
	
	/*
	 * pour chaque action dans l'ensemble d'actions
	 * on se déplace a l'emplacement définis dans la génération de l'action et on éxécute l'Item sur la cible définis.
	 */
	play(){
		// debug(this)
		// étape 1: je fais mes actions
		for(var action in this.actions){
			debug(action)
			debug(action.consequences)
			if(action.from != Fight.selfCell) moveTowardCell(action.from)
			if(action.to == Fight.selfCell) action.item.useItemOnCell(Map.getCell(getCell()))
			else action.item.useItemOnCell(action.to)
		}
		// étape 2: je vais me planquer
		if(this.finalDanger){
			MapDanger.showDanger(Map.getCell(getCell()), getMP(), this.getCurrentConsequences())
			//debug(this.finalDanger)
			moveTowardCell(this.finalDanger.cell)
		}
		// étape 3: si il reste des TP, je prend en main la meilleure arme vis à vis de la situation
		if(getWeapon(Fight.self)==null) setWeapon(Items.getItem(WEAPON_MAGNUM))
		// étape 4: si il reste des TP, je dis des trucs
		// todo pipotron
	}
	
	/*
	 * Format chaîne de caractères utilisée pour des tests / debugs.
	 */
	string(){
		var str= '<Combo: ['
		for(var action in this.actions){
			str+= '\n'+action
		}
		str+= '\n'+this.finalDanger+']>'
		return str
	}
}